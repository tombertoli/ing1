

----QUIT----(20 March 2023 11:15:29) CuisUniversity-5706.image priorSource: 4313282!

----STARTUP---- (20 March 2023 11:15:29) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5706.image!


----QUIT----(20 March 2023 11:15:30) CuisUniversity-5706.image priorSource: 8712809!

----STARTUP---- (20 April 2023 17:48:13) as /home/clinux01/Descargas/linux64/CuisUniversity-5706.image!


----End fileIn of /home/clinux01/Descargas/ISW1-2022-2C-1erParcial.st----!
!Island methodsFor: 'nil' stamp: 'a 4/20/2023 18:08:08'!
xxx: yyy zzz: ppp

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(yyy = pos) ifTrue: [ ^ ppp].
		
		ix := ix + 1.
	].
	! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:09:42'!
find: element atTreesAtCollectionAndExecute: aClosure

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [ ^ aClosure].
		
		ix := ix + 1.
	].
	! !

!methodRemoval: Island #xxx:zzz: stamp: 'a 4/20/2023 18:10:27'!
xxx: yyy zzz: ppp

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(yyy = pos) ifTrue: [ ^ ppp].
		
		ix := ix + 1.
	].
	!
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:15:40' prior: 50604545!
find: element atTreesAtCollectionAndExecute: aClosure

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [^ aClosure value].
		
		ix := ix + 1.
	].
	! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:16:30' prior: 50604410!
isEmptyAt: aPosition

	self find: aPosition atTreesAtColeectionAndExecute: [^false].
	^ true! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:16:56' prior: 50604572!
isEmptyAt: aPosition

	self find: aPosition atTreesAtCollectionAndExecute: [^false].
	^ true! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:22:15'!
find: element atTreesAtCollectionAndExecute: aClosure yyy:xxx

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [^ aClosure value:xxx].
		
		ix := ix + 1.
	].
	! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:24:27' prior: 50604562!
find: element atTreesAtCollectionAndExecute: aClosure

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [^ aClosure value:ix].
		
		ix := ix + 1.
	].
	! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:24:41' prior: 50604386!
clearTerrainAt: aPosition

	self find: aPosition atTreesAtCollectionAndExecute: [:ix | ^treesAt removeIndex: ix] .
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:25:16' prior: 50604578!
isEmptyAt: aPosition

	self find: aPosition atTreesAtCollectionAndExecute: [:ix|^false].
	^ true! !

!methodRemoval: Island #find:atTreesAtCollectionAndExecute:yyy: stamp: 'a 4/20/2023 18:25:19'!
find: element atTreesAtCollectionAndExecute: aClosure yyy:xxx

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [^ aClosure value:xxx].
		
		ix := ix + 1.
	].
	!
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:27:32' prior: 50604424!
terrainAt: aPosition

	self find: aPosition atTreesAtCollectionAndExecute: [^#Tree].
	
	self find: aPosition atTreesAtCollectionAndExecute: [^#Diggable].
	
	"ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^ #Diggable ].
		ix := ix + 1.
	].
	"

	^ #Empty.
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:27:42' prior: 50604627!
terrainAt: aPosition

	self find: aPosition atTreesAtCollectionAndExecute: [^#Tree].
	self find: aPosition atTreesAtCollectionAndExecute: [^#Diggable].
	
	"ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^ #Diggable ].
		ix := ix + 1.
	].
	"

	^ #Empty.
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:32:10'!
find: element atTreesAtCollectionAndExecute: aClosure aCollection: aCollection 

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [^ aClosure value:ix].
		
		ix := ix + 1.
	].
	! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:32:10' prior: 50604640!
terrainAt: aPosition

	self find: aPosition atTreesAtCollectionAndExecute: [^#Tree] aCollection: 0.
	self find: aPosition atTreesAtCollectionAndExecute: [^#Diggable] aCollection: 0.
	
	"ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^ #Diggable ].
		ix := ix + 1.
	].
	"

	^ #Empty.
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:32:10' prior: 50604604!
clearTerrainAt: aPosition

	self find: aPosition atTreesAtCollectionAndExecute: [:ix | ^treesAt removeIndex: ix] aCollection: 0 .
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:32:10' prior: 50604611!
isEmptyAt: aPosition

	self find: aPosition atTreesAtCollectionAndExecute: [:ix|^false] aCollection: 0.
	^ true! !

!methodRemoval: Island #find:atTreesAtCollectionAndExecute: stamp: 'a 4/20/2023 18:32:10'!
find: element atTreesAtCollectionAndExecute: aClosure

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [^ aClosure value:ix].
		
		ix := ix + 1.
	].
	!
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:33:03'!
find: element atCollection: aClosure andExecute: aCollection 

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [^ aClosure value:ix].
		
		ix := ix + 1.
	].
	! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:33:03' prior: 50604686!
isEmptyAt: aPosition

	self find: aPosition atCollection: [:ix|^false] andExecute: 0.
	^ true! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:33:03' prior: 50604678!
clearTerrainAt: aPosition

	self find: aPosition atCollection: [:ix | ^treesAt removeIndex: ix] andExecute: 0 .
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:33:03' prior: 50604664!
terrainAt: aPosition

	self find: aPosition atCollection: [^#Tree] andExecute: 0.
	self find: aPosition atCollection: [^#Diggable] andExecute: 0.
	
	"ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^ #Diggable ].
		ix := ix + 1.
	].
	"

	^ #Empty.
	
! !

!methodRemoval: Island #find:atTreesAtCollectionAndExecute:aCollection: stamp: 'a 4/20/2023 18:33:03'!
find: element atTreesAtCollectionAndExecute: aClosure aCollection: aCollection 

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [^ aClosure value:ix].
		
		ix := ix + 1.
	].
	!
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:33:14' prior: 50604702!
find: element atCollection: aCollection andExecute: aClosure 

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(element = pos) ifTrue: [^ aClosure value:ix].
		
		ix := ix + 1.
	].
	! !

Island!
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:34:35' prior: 50604718!
clearTerrainAt: aPosition

	self find: aPosition atCollection:crewAt   andExecute: [:ix | ^treesAt removeIndex: ix].
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:34:38' prior: 50604760!
clearTerrainAt: aPosition

	self find: aPosition atCollection:crewAt andExecute: [:ix | ^treesAt removeIndex: ix].
	
! !

----STARTUP---- (20 April 2023 18:35:51) as /home/clinux01/Descargas/linux64/CuisUniversity-5706.image!


----End fileIn of /home/clinux01/Descargas/ISW1-2022-2C-1erParcial.st----!
!Island methodsFor: 'nil' stamp: 'a 4/20/2023 18:52:37'!
findAtCollection:aGivenCollection anElementNamed:nameOfAPossibleElement andExecute:aClosure	
	| ix |
	
	ix := 1.
	[ix <= aGivenCollection size] whileTrue: [ | pos |
		pos := aGivenCollection at: ix.
		(nameOfAPossibleElement = pos) ifTrue: [aClosure value: ix].
		
		ix := ix + 1.
	].! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:53:48' prior: 50604386!
clearTerrainAt: aPosition
	
	self findAtCollection: treesAt anElementNamed:aPosition andExecute: [^treesAt removeIndex ix].
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:54:47' prior: 50604549!
clearTerrainAt: aPosition
	
	self findAtCollection: treesAt anElementNamed:aPosition andExecute: [:ix|^treesAt removeIndex: ix].
	"| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	]."
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:55:48' prior: 50604410!
isEmptyAt: aPosition
	
	self findAtCollection: treesAt anElementNamed: aPosition  andExecute: [^false]. 
"
	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ false ].
		
		ix := ix + 1.
	].
"
	^ true! !
!Island methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 18:57:17' prior: 50604424!
terrainAt: aPosition
	
	self findAtCollection: treesAt anElementNamed:aPosition andExecute: [^#Tree].
"
	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ #Tree ].		
		ix := ix + 1.
	].
"
	self findAtCollection: digsAt anElementNamed: aPosition andExecute: [^#Diggable].
"
	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^ #Diggable ].
		ix := ix + 1.
	].
"
	^ #Empty.
	
! !
!Crew methodsFor: 'nil' stamp: 'a 4/20/2023 19:12:07'!
aGivenPirate: pirate IsOfKindOf: xxx andIsAtSpot: terrain andIfSpotIsATreeExecute: executeIfIsTree ifItIsEmptyExecute: executeIfIsEmpty andIfItIsADiggableExecute: executeIfIsDiggable
	(pirate isKindOf: xxx) ifTrue: [ 
			terrain = #Tree ifTrue: [executeIfIsTree value].
			terrain = #Empty ifTrue: [executeIfIsEmpty value].
			terrain = #Diggable ifTrue: [ 		executeIfIsDiggable value ].
		].! !
!Crew methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 19:14:03' prior: 50604256!
buryTreasureAt: aPosition

	| ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	ix := 1.
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		self aGivenPirate: pirate IsOfKindOf: Corsario  andIsAtSpot: terrain  andIfSpotIsATreeExecute: [] ifItIsEmptyExecute: [] andIfItIsADiggableExecute: [].
		"
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [ 				pirate drawTreasureMarkAt: aPosition ].
		].
		"
		self aGivenPirate: pirate IsOfKindOf: Filibustero  andIsAtSpot: terrain  andIfSpotIsATreeExecute: [] ifItIsEmptyExecute: [] andIfItIsADiggableExecute: [].
		"
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [].
		].
		"
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ].
			terrain = #Empty ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	.
			terrain = #Diggable ifTrue: [ island receiveTreasureAt: aPosition ].
		].
		
		ix := ix + 1.
	].
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 19:15:37' prior: 50604615!
buryTreasureAt: aPosition

	| ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	ix := 1.
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		self aGivenPirate: pirate IsOfKindOf: Corsario  andIsAtSpot: terrain  andIfSpotIsATreeExecute: [] ifItIsEmptyExecute: [] andIfItIsADiggableExecute: [].
		"
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [ 				pirate drawTreasureMarkAt: aPosition ].
		].
		"
		self aGivenPirate: pirate IsOfKindOf: Filibustero  andIsAtSpot: terrain  andIfSpotIsATreeExecute: [] ifItIsEmptyExecute: [] andIfItIsADiggableExecute: [].
		"
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [].
		].
		"
		self aGivenPirate: pirate IsOfKindOf: Bucanero  andIsAtSpot:   terrain andIfSpotIsATreeExecute: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ] ifItIsEmptyExecute:  [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	 andIfItIsADiggableExecute: [ island receiveTreasureAt: aPosition ].
		"
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ].
			terrain = #Empty ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	.
			terrain = #Diggable ifTrue: [ island receiveTreasureAt: aPosition ].
		].
		"
		ix := ix + 1.
	].
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 19:18:49' prior: 50604599!
aGivenPirate: pirate IsOfKindOf: pirateGroup andIsAtSpot: terrain andIfSpotIsATreeExecute: executeIfIsTree ifItIsEmptyExecute: executeIfIsEmpty andIfItIsADiggableExecute: executeIfIsDiggable
	(pirate isKindOf: pirateGroup) ifTrue: [ 
			terrain = #Tree ifTrue: [executeIfIsTree value].
			terrain = #Empty ifTrue: [executeIfIsEmpty value].
			terrain = #Diggable ifTrue: [ 		executeIfIsDiggable value ].
		].! !
!Crew methodsFor: 'as yet unclassified' stamp: 'a 4/20/2023 19:23:09' prior: 50604292!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		self aGivenPirate: pirate IsOfKindOf: Corsario  andIsAtSpot: terrain  andIfSpotIsATreeExecute: [ acc := acc & false] ifItIsEmptyExecute: [pirate drawDirectionTo: aPosition.
				acc := acc & true ]  andIfItIsADiggableExecute: [ acc := acc & true ].
		"
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		"
		self aGivenPirate: pirate IsOfKindOf: Filibustero  andIsAtSpot: terrain andIfSpotIsATreeExecute: 
		[ island clearTerrainAt: aPosition. 
		acc := acc & false] ifItIsEmptyExecute: [ acc := acc & true ]  andIfItIsADiggableExecute: [ acc := acc & true ].
		"
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		"
		self aGivenPirate: pirate IsOfKindOf: Bucanero  andIsAtSpot: terrain  andIfSpotIsATreeExecute: [ acc := acc & false ] ifItIsEmptyExecute: [ acc := acc & false ] andIfItIsADiggableExecute: [ acc := acc & false ].
		"
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		"
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

----STARTUP---- (20 April 2023 21:03:53) as /home/clinux01/Descargas/linux64/CuisUniversity-5706.image!


----End fileIn of /home/clinux01/Descargas/Stack-Exercise.st----!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:04:36'!
ERROR!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:04:56'!
ERROR!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:05:03'!
ERROR!

Object subclass: #OOStack
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:06:10'!
Object subclass: #OOStack
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack class methodsFor: 'error descriptions' stamp: 'l 4/20/2023 21:07:00' overrides: 16785646!
new 
	OOStack new initializeEmpty! !
!OOStack methodsFor: 'no messages' stamp: 'l 4/20/2023 21:08:27'!
initializeEmpty 
	container:=LinkedList new ! !
!OOStack methodsFor: 'nil' stamp: 'l 4/20/2023 21:08:45'!
isEmpty 
	^container isEmpty! !
!OOStack class methodsFor: 'error descriptions' stamp: 'l 4/20/2023 21:09:51' prior: 50604173 overrides: 16785646!
new 
	super new intializeEmpty! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:09:56'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:09:56'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:09:56'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:09:56'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:09:56'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:09:56'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:09:56'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:09:56'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:09:56'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:09:56'!
ERROR!

OOStack new!

OOStack new!

!methodRemoval: OOStack class #new stamp: 'l 4/20/2023 21:10:42'!
new 
	super new intializeEmpty!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:10:50' overrides: 16920235!
initialize
	container:=LinkedList new ! !

!methodRemoval: OOStack #initializeEmpty stamp: 'l 4/20/2023 21:10:52'!
initializeEmpty 
	container:=LinkedList new !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:10:56'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:10:56'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:10:56'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:10:56'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:10:56'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:10:56'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:10:56'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:10:56'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:10:56'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:10:56'!
ERROR!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:12:01'!
push: anElement  		
	container addLast: anElement ! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:12:05'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:12:05'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:12:05'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:12:05'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:12:05'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:12:05'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:12:05'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:12:05'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:12:05'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:12:05'!
ERROR!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:13:05'!
pop 
	^container removeLast! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:13:07'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:13:07'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:13:07'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:13:07'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:13:07'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:13:07'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:13:07'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:13:07'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:13:07'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:13:07'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:13:17'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:13:17'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:13:28'!
ERROR!

Link new!

Link new: 2!

Link nextLink!

Link nextLink: 2!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:19:24' prior: 50604226 overrides: 16920235!
initialize
	container:=Array new ! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:20:58'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:20:59'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:20:59'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:20:59'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:20:59'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:20:59'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:20:59'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:20:59'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:20:59'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:20:59'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:21:03'!
ERROR!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:21:24' prior: 50604266!
push: anElement  		
	container addLast: anElement! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:21:27'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:21:27'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:21:27'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:21:27'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:21:27'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:21:27'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:21:27'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:21:27'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:21:27'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:21:27'!
ERROR!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:21:36' prior: 50604390!
push: anElement  		
	container add: anElement! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:21:40'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:21:40'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:21:40'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:21:40'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:21:40'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:21:40'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:21:40'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:21:40'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:21:40'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:21:40'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:21:44'!
ERROR!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:23:40' prior: 50604351 overrides: 16920235!
initialize
	container:=OrderedCollection new ! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:23:53'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:23:53'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:23:53'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:23:53'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:23:53'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:23:53'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:23:53'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:23:53'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:23:53'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:23:53'!
ERROR!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:24:19'!
top 
	^container last ! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:24:21'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:24:21'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:24:21'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:24:21'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:24:21'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:24:21'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:24:21'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:24:21'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:24:21'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:24:22'!
FAILURE!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:24:38' prior: 50604504!
top 
	^container top ! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:24:40'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:24:40'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:24:40'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:24:40'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:24:40'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:24:40'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:24:40'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:24:40'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:24:40'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:24:40'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:24:43'!
ERROR!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:24:53' prior: 50604540!
top 
	^container last! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:24:55'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:24:55'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:24:55'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:24:55'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:24:55'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:24:55'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:24:55'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:24:55'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:24:55'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:24:55'!
FAILURE!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:24:58'!
ERROR!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:25:15' overrides: 16901663!
size 
	^container size! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:25:19'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:25:19'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:25:19'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:25:19'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:25:19'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:25:19'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:25:19'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:25:19'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:25:19'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:25:19'!
FAILURE!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:25:26'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:25:26'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:25:26'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:25:26'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:25:26'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:25:26'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:25:26'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:25:26'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:25:26'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:25:26'!
FAILURE!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:25:27'!
FAILURE!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:26:58' prior: 50604303!
pop 
	(self isEmpty) ifTrue: [
		self error: self class stackEmptyErrorDescription 
		].
	
	^container removeLast! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:27:00'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:27:00'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:27:00'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:27:00'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:27:00'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:27:00'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:27:00'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:27:00'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:27:00'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:27:00'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:27:00'!
FAILURE!
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:27:39' prior: 50604579!
top 
	(self isEmpty) ifTrue: [
		self error: self class stackEmptyErrorDescription 
		].
	
	^container last! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:27:41'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:27:41'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:27:41'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:27:41'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:27:41'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:27:41'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:27:41'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:27:41'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:27:41'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:27:41'!
PASSED!

OOStack subclass: #EmptyOOStack
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStack subclass: #EmptyOOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyOOStack category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:28:55'!
OOStack subclass: #EmptyOOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!EmptyOOStack methodsFor: 'no messages' stamp: 'l 4/20/2023 21:29:36' overrides: 50604734!
top 
	self error: self class stackEmptyErrorDescription! !

OOStack subclass: #NotEmptyOOStack
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStack subclass: #NotEmptyOOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyOOStack category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:30:02'!
OOStack subclass: #NotEmptyOOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!NotEmptyOOStack methodsFor: 'no messages' stamp: 'l 4/20/2023 21:30:15' overrides: 50604734!
top 
	^container last! !

Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:30:21'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStack subclass: #NotEmptyOOStack
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyOOStack category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:30:26'!
OOStack subclass: #NotEmptyOOStack
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!methodRemoval: OOStack #initialize stamp: 'l 4/20/2023 21:30:57'!
initialize
	container:=OrderedCollection new !
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:31:06' prior: 50604181!
isEmpty 
	self subclassResponsibility ! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:31:14' prior: 50604734!
top 
	self subclassResponsibility ! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:31:24' prior: 50604619 overrides: 16901663!
size 
	self subclassResponsibility ! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:31:29' prior: 50604427!
push: anElement  		
	self subclassResponsibility ! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:31:33' prior: 50604691!
pop 
	self subclassResponsibility ! !
!EmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:31:48' overrides: 50604840!
isEmpty 
	^true! !
!EmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:32:04' overrides: 50604860!
pop 
	self error: self class stackEmptyErrorDescription ! !
!EmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:32:48' overrides: 50604855!
push: anElement
	NotEmptyOOStack new ! !
!EmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:32:58' prior: 50604874 overrides: 50604855!
push: anElement
	^NotEmptyOOStack new push: anElement! !
!NotEmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:33:23' overrides: 16920235!
initialize 
	container := OrderedCollection new! !
!EmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:33:39' overrides: 50604850!
size 
	^0
	! !
!NotEmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:34:03' overrides: 50604855!
push: anElement
	container add: anElement ! !
!NotEmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:34:14' overrides: 50604850!
size
	^container size! !
!NotEmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:34:30' overrides: 50604860!
pop 
	container removeLast ! !
!NotEmptyOOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:34:44' overrides: 50604840!
isEmpty 
	^false! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:34:48'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'l 4/20/2023 21:34:48'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'l 4/20/2023 21:34:48'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'l 4/20/2023 21:34:48'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'l 4/20/2023 21:34:48'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'l 4/20/2023 21:34:48'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'l 4/20/2023 21:34:48'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:34:48'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'l 4/20/2023 21:34:48'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'l 4/20/2023 21:34:48'!
FAILURE!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'l 4/20/2023 21:34:53'!
ERROR!
!OOStack class methodsFor: 'error descriptions' stamp: 'l 4/20/2023 21:35:23' overrides: 16785646!
new 
	^EmptyOOStack new! !

!methodRemoval: OOStack class #new stamp: 'l 4/20/2023 21:37:05'!
new 
	^EmptyOOStack new!

!classRemoval: #EmptyOOStack stamp: 'l 4/20/2023 21:45:21'!
OOStack subclass: #EmptyOOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #NotEmptyOOStack stamp: 'l 4/20/2023 21:45:23'!
OOStack subclass: #NotEmptyOOStack
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackState category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:47:16'!
Object subclass: #OOStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStack
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:48:42'!
Object subclass: #OOStack
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'nil' stamp: 'l 4/20/2023 21:49:25' overrides: 16920235!
initialize
	^container:=OrderedCollection  new! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'l 4/20/2023 21:49:33' prior: 50604840!
isEmpty 
	^container size ! !

OOStack subclass: #OOStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackState category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:50:28'!
OOStack subclass: #OOStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackState category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:51:11'!
Object subclass: #OOStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStackState subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #Empty category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:51:40'!
OOStackState subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStackState subclass: #EmptyStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStackState category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:52:03'!
OOStackState subclass: #EmptyStackState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRenamed: #Empty as: #NonEmptyStackState stamp: 'l 4/20/2023 21:52:43'!
Smalltalk renameClassNamed: #Empty as: #NonEmptyStackState!

OOStackState subclass: #NonEmptyStackState
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NonEmptyStackState category: 'Stack-Exercise' stamp: 'l 4/20/2023 21:53:00'!
OOStackState subclass: #NonEmptyStackState
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!NonEmptyStackState methodsFor: 'no messages' stamp: 'l 4/20/2023 21:54:28'!
pop
	container removeLast 
	! !

----STARTUP---- (27 April 2023 18:03:34) as /home/clinux01/Descargas/linux64/CuisUniversity-5706.image!


----End fileIn of /home/clinux01/Descargas/TDDBabyStepsGame.st----!

| game |
game  := TDDBabyStepsGameContador start.
game openHelp.
game openDefinition.
game next.!

!classDefinition: #TDDBabyStepsContadorTest category: 'TDDBabyStepsGameContador' stamp: 'TB 4/27/2023 18:08:45'!
TestCase subclass: #TDDBabyStepsContadorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameContador'!
!TDDBabyStepsContadorTest methodsFor: 'tests' stamp: 'TB 4/27/2023 18:08:45'!
test01UnNuevoContadorEmpiezaConValorCero

	| contador |
		
	contador := Contador new.
	self assert: 0 equals: contador valor.
	! !

!testRun: #TDDBabyStepsContadorTest #test01UnNuevoContadorEmpiezaConValorCero stamp: 'TB 4/27/2023 18:09:31'!
ERROR!

!classDefinition: #Contador category: 'TDDBabyStepsGameContador' stamp: 'TB 4/27/2023 18:09:55'!
Object subclass: #Contador
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameContador'!
!TDDBabyStepsContadorTest methodsFor: 'tests' stamp: 'TB 4/27/2023 18:09:49' prior: 50605749!
test01UnNuevoContadorEmpiezaConValorCero

	| contador |
		
	contador := Contador new.
	self assert: 0 equals: contador valor.
	
	! !
!TDDBabyStepsContadorTest methodsFor: 'tests' stamp: 'TB 4/27/2023 18:10:00' prior: 50605768!
test01UnNuevoContadorEmpiezaConValorCero

	| contador |
		
	contador := Contador new.
	self assert: 0 equals: contador valor.
	! !

!testRun: #TDDBabyStepsContadorTest #test01UnNuevoContadorEmpiezaConValorCero stamp: 'TB 4/27/2023 18:10:04'!
ERROR!
!Contador methodsFor: 'accessing' stamp: 'TB 4/27/2023 18:10:10'!
valor
	self shouldBeImplemented.! !
!Contador methodsFor: 'accessing' stamp: 'TB 4/27/2023 18:10:13' prior: 50605786!
valor
	^0! !

!testRun: #TDDBabyStepsContadorTest #test01UnNuevoContadorEmpiezaConValorCero stamp: 'TB 4/27/2023 18:10:16'!
PASSED!

!testRun: #TDDBabyStepsContadorTest #test01UnNuevoContadorEmpiezaConValorCero stamp: 'TB 4/27/2023 18:10:16'!
PASSED!

!testRun: #TDDBabyStepsContadorTest #test01UnNuevoContadorEmpiezaConValorCero stamp: 'TB 4/27/2023 18:10:25'!
PASSED!
!TDDBabyStepsContadorTest methodsFor: 'tests' stamp: 'TB 4/27/2023 18:10:25'!
test02AlIncrementarUnaVezElContadorSuValorSubeUno

	| contador |

	contador := Contador new.
	contador incrementar.
	self assert: 1 equals: contador valor.
	! !

!testRun: #TDDBabyStepsContadorTest #test02AlIncrementarUnaVezElContadorSuValorSubeUno stamp: 'TB 4/27/2023 18:10:25'!
ERROR!

!methodRemoval: TDDBabyStepsContadorTest #test02AlIncrementarUnaVezElContadorSuValorSubeUno stamp: 'TB 4/27/2023 18:10:25'!
test02AlIncrementarUnaVezElContadorSuValorSubeUno

	| contador |

	contador := Contador new.
	contador incrementar.
	self assert: 1 equals: contador valor.
	!
!TDDBabyStepsContadorTest methodsFor: 'tests' stamp: 'TB 4/27/2023 18:10:25'!
test02AlIncrementarUnaVezElContadorSuValorSubeUno

	| contador |

	contador := Contador new.
	contador incrementar.
	self assert: 1 equals: contador valor.
	! !

!testRun: #TDDBabyStepsContadorTest #test02AlIncrementarUnaVezElContadorSuValorSubeUno stamp: 'TB 4/27/2023 18:10:25'!
ERROR!

!classRemoval: #Contador stamp: 'TB 4/27/2023 18:11:34'!
Object subclass: #Contador
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameContador'!

!classRemoval: #TDDBabyStepsContadorTest stamp: 'TB 4/27/2023 18:11:35'!
TestCase subclass: #TDDBabyStepsContadorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameContador'!

| game |
game  := TDDBabyStepsGameCuentaBancaria start.
game openHelp.
game openDefinition.
game next.!

!classDefinition: #TDDBabyStepsCuentaBancariaEnPesosTest category: 'TDDBabyStepsGameCuentaBancariaEnPesos' stamp: 'TB 4/27/2023 18:11:44'!
TestCase subclass: #TDDBabyStepsCuentaBancariaEnPesosTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameCuentaBancariaEnPesos'!
!TDDBabyStepsCuentaBancariaEnPesosTest methodsFor: 'tests' stamp: 'TB 4/27/2023 18:11:44'!
test01UnaNuevaCuentaComienzaConSaldoCero
	
	self assert: 0 * peso equals: CuentaBancariaEnPesos new saldo.
	! !

!classRemoval: #TDDBabyStepsCuentaBancariaEnPesosTest stamp: 'TB 4/27/2023 18:11:57'!
TestCase subclass: #TDDBabyStepsCuentaBancariaEnPesosTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameCuentaBancariaEnPesos'!

| game |
game  := TDDBabyStepsGameRot13 start.
game openHelp.
game openDefinition.
game next.!

!classDefinition: #TDDBabyStepsRot13Test category: 'TDDBabyStepsGameRot13' stamp: 'TB 4/27/2023 18:12:19'!
TestCase subclass: #TDDBabyStepsRot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameRot13'!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:12:19'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:14:33'!
ERROR!

!classRemoval: #TDDBabyStepsRot13Test stamp: 'TB 4/27/2023 18:14:47'!
TestCase subclass: #TDDBabyStepsRot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameRot13'!

TDDBabyStepsGameRot13 start!

!classDefinition: #TDDBabyStepsRot13Test category: 'TDDBabyStepsGameRot13' stamp: 'TB 4/27/2023 18:14:57'!
TestCase subclass: #TDDBabyStepsRot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameRot13'!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:15:41'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:15:56'!
ERROR!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:16:04'!
asRot13
	self shouldBeImplemented.! !
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:16:08' prior: 50605927!
asRot13
	^$n! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:16:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:16:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:16:15'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:16:15'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:16:15'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:16:15'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:16:15'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:16:15'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:16:32'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:18:36' prior: 50605931!
asRot13
	^self class asciiValue: self asciiValue + 13! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:18:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:18:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:18:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:18:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:18:41'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:18:41'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:18:41'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:18:41'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:18:41'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:18:41'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:18:49'!
FAILURE!

$n asciiValue!

$n asciiValue - $a asciiValue!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:21:59' prior: 50605981!
asRot13
	self = $n ifTrue: [^$a].
	^self class asciiValue: self asciiValue + 13! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:04'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:22:04'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:04'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:04'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:22:04'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:22:04'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:24:09' prior: 50606043!
asRot13
	self asciiValue >= $n asciiValue ifTrue: [^self class asciiValue: self asciiValue - 13 ].
	^self class asciiValue: self asciiValue + 13! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:24:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:24:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:24:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:24:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:24:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:24:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:24:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:24:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:24:20'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:24:20'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:24:20'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:24:20'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:24:20'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:24:20'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:26:11' prior: 50606108!
asRot13
	^self class asciiValue: self asciiValue + 13 * (self asciiValue >= $n asciiValue ifTrue: [-1] ifFalse: [1])! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:13'!
ERROR!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:26:25' prior: 50606179!
asRot13
	^self class asciiValue: self asciiValue + (13 * (self asciiValue >= $n asciiValue ifTrue: [-1] ifFalse: [1]))! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:26'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:26'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:26'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:26'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:26'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:26:26'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:26:26'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:26:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:26:32'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:26:32'!
FAILURE!
!Character methodsFor: 'accessing' stamp: 'TB 4/27/2023 18:28:16'!
isFromTheSecondPartOfTheAlphabet

	^self asciiValue >= $n asciiValue! !
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:29:06' prior: 50606190!
asRot13
	
	
	^self class asciiValue: self asciiValue + (13 * (self isFromTheSecondPartOfTheAlphabet ifTrue: [-1] ifFalse: [1]))! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:29:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:29:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:29:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:29:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:29:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:29:07'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:29:07'!
FAILURE!

$m asciiValue!

$m asciiValue - $a asciiValue!

$n asciiValue - $a asciiValue!

$m asciiValue - $a asciiValue!

$m asciiValue - $n asciiValue!
!Character methodsFor: 'accessing' stamp: 'TB 4/27/2023 18:31:52'!
rot13Complement

	^13 * (self isFromTheSecondPartOfTheAlphabet ifTrue: [-1] ifFalse: [1])! !
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:31:59' prior: 50606260!
asRot13
	
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:32:01'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:32:01'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:32:18' prior: 50606306!
asRot13
	
	self = $` ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:32:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:32:23'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:32:23'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:32:23'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:32:23'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:32:23'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:32:23'!
FAILURE!

	self asciiValue >= $` asciiValue ifTrue: [^self].!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:32:39' prior: 50606341!
asRot13
	
	self asciiValue >= $` asciiValue ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:32:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:40'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:40'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:40'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:32:40'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:32:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:32:40'!
PASSED!

$` asciiValue!

${ asciiValue!

$n asciiValue!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:33:25' prior: 50606420!
asRot13
	
	self isCharacter asciiValue ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:33:27'!
ERROR!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:33:32' prior: 50606457!
asRot13
	
	self isCharacter ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:33:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:33:35'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:33:35'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:33:35'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:33:35'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:33:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:33:35'!
PASSED!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:34:14' prior: 50606467!
asRot13
	
	self isLetter ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:34:18'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:34:28' prior: 50606502!
asRot13
	
	self isLetter ifFalse: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:34:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:34:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:34:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:34:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:34:32'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:34:32'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:32'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:34:32'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:35:06' prior: 50606512!
asRot13
	
	self asciiValue >= $` asciiValue ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:35:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:35:07'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:35:07'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:35:07'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:35:07'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:35:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:35:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:35:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:35:44'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:35:44'!
FAILURE!

$z asciiValue !
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:37:30' prior: 50606592!
asRot13
	
	(self asciiValue between: $` asciiValue and: $` asciiValue) ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:37:32'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:37:32'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:38:04' prior: 50606641!
asRot13
	
	(self asciiValue between: $` asciiValue and: ${ asciiValue) ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:09'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:38:35' prior: 50606682!
asRot13
	
	(self asciiValue between: $a asciiValue and: $z asciiValue) not ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:38:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:38:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:38:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:38:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:38:42'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:38:42'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:42'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:42'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:38:42'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:42'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:38:54'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:39:51' prior: 50606694!
asRot13
	
	self = $N ifTrue: [^$A].
		
	(self asciiValue between: $a asciiValue and: $z asciiValue) not ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:39:53'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:40:47' prior: 50606793!
asRot13
	
	self isUppercase ifTrue: [^self class asciiValue: self asciiValue + 13].
		
	(self asciiValue between: $a asciiValue and: $z asciiValue) not ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:49'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:49'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:49'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:49'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:49'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:40:49'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:40:49'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:49'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:40:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:40:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:51'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:40:51'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:51'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:51'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:40:51'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:40:51'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 18:41:04' prior: 50606806!
asRot13
	
	self isUppercase ifTrue: [^self class asciiValue: self asciiValue + self rot13Complement].
		
	(self asciiValue between: $a asciiValue and: $z asciiValue) not ifTrue: [^self].
	^self class asciiValue: self asciiValue + self rot13Complement! !
!Character methodsFor: 'testing' stamp: 'TB 4/27/2023 18:41:41' prior: 50606255!
isFromTheSecondPartOfTheAlphabet

	^self asciiValue >= $n asciiValue or: [self asciiValue >= $N].! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:41:47'!
ERROR!
!Character methodsFor: 'testing' stamp: 'TB 4/27/2023 18:42:03' prior: 50606923!
isFromTheSecondPartOfTheAlphabet

	^self asciiValue >= $n asciiValue or: [self asciiValue >= $N asciiValue].! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:42:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:42:06'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:42:06'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:42:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:42:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:42:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:42:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:42:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:42:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:42:16'!
FAILURE!

$N asRot13!

$n asRot13!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:42:50'!
FAILURE!

$a asRot13!

$a isFromTheSecondPartOfTheAlphabet !
!Character methodsFor: 'testing' stamp: 'TB 4/27/2023 18:44:14' prior: 50606934!
isFromTheSecondPartOfTheAlphabet

	^(self asciiValue between: $n asciiValue and: $z asciiValue) or: [
		self asciiValue between: $N asciiValue and: $Z asciiValue
		].! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:18'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:18'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:18'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:18'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:18'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:44:18'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:44:18'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:18'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:18'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:44:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:44:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:44:20'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:44:20'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:44:20'!
ERROR!

!methodRemoval: TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:44:20'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:44:20'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:44:20'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:44:29'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:44:43'!
ERROR!
!String methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 18:44:57'!
asRot13
	self shouldBeImplemented.! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:45:38'!
ERROR!
!String methodsFor: 'error handling' stamp: 'TB 4/27/2023 18:46:20' overrides: 16902107!
error: aRenameMe1 
	self shouldBeImplemented.! !
!String methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 18:46:44' prior: 50607099!
asRot13
	^''! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:46:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:46:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:46:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:46:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:46:50'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:46:50'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:46:50'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:46:50'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:46:50'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:46:50'!
FAILURE!

'' first!

'a' first!

	^self first asRot13 asString!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:50:50'!
FAILURE!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:51:01' prior: 50607112!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self first asRot13 asString! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:51:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:51:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:51:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:51:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:51:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:51:05'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:51:05'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:51:05'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:51:05'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:51:05'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:51:05'!
FAILURE!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:51:31' prior: 50607233!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self do: [:aCharacter | aCharacter asRot13].! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:51:34'!
FAILURE!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:52:30' prior: 50607347!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self collect: [:aCharacter | aCharacter asRot13].! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:52:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:52:33'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:52:33'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 18:52:33'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 18:52:33'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:53:06' prior: 50607356!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self first asRot13, (self at: 2) asRot13! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:53:07'!
ERROR!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:53:16' prior: 50607469!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self first asRot13, (self at: 2) asRot13 asString! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:53:17'!
ERROR!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:53:25' prior: 50607478!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self first asRot13 asString, (self at: 2) asRot13! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:53:26'!
ERROR!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:53:41' prior: 50607487!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self first asRot13 asString, (self at: 2) asRot13 asString! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:53:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:54:12'!
PASSED!

'hola', 'chau'!

$a asString, $b asString!

'holla' at: 2!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:55:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:55:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:55:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:55:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:55:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:55:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:55:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:55:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:55:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:55:34'!
PASSED!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:56:01' prior: 50607496!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self first asRot13 asString, ((self at: 2) asRot13 asString)! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:56:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:56:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:56:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:56:02'!
PASSED!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:56:07' prior: 50607626!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self first asRot13 asString, (self at: 2) asRot13 asString! !

'ho' asRot13!

'az' asRot13 !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:56:43'!
PASSED!

!methodRemoval: String #error: stamp: 'TB 4/27/2023 18:57:23'!
error: aRenameMe1 
	self shouldBeImplemented.!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:57:30'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:57:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:57:30'!
ERROR!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:58:21' prior: 50607673!
asRot13
	
	self isEmpty ifTrue: [^self].
	self size <= 1 ifTrue: [^self first asRot13 asString].
	^self first asRot13 asString, (self at: 2) asRot13 asString! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:58:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:58:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:58:25'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:58:25'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 18:58:25'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 18:58:25'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:58:25'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 18:58:25'!
FAILURE!
!String methodsFor: 'converting' stamp: 'TB 4/27/2023 18:58:47' prior: 50607775!
asRot13
	
	self isEmpty ifTrue: [^self].
	^self collect: [:aCharacter | aCharacter asRot13]! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 18:58:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 18:58:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 18:58:50'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TB 4/27/2023 18:58:50'!
testExtraToCheckGeneralizationOnKata
		
	self assert: 'Ju3er j3 4e3 t01at j3 q0ag a3rq e04q$...' equals: 'Wh3re w3 4r3 g01ng w3 d0nt n3ed r04d$...' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'TB 4/27/2023 18:58:50'!
PASSED!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 19:05:02' prior: 50606912!
asRot13
	
	(self isUppercase or: [self isLowercase]) ifTrue: [^self class asciiValue: self asciiValue + self rot13Complement].
	^self! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 19:05:07'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'TB 4/27/2023 19:05:07'!
PASSED!
!Character methodsFor: 'converting' stamp: 'TB 4/27/2023 19:11:46' prior: 50608017!
asRot13
	
	self isLetter ifTrue: [^self class asciiValue: self asciiValue + self rot13Complement].
	^self! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TB 4/27/2023 19:11:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'TB 4/27/2023 19:11:48'!
PASSED!
!Character methodsFor: 'testing' stamp: 'TB 4/27/2023 19:13:38' prior: 50606990!
isFromTheSecondPartOfTheAlphabet

	^(self asciiValue between: $n asciiValue and: $z asciiValue) or: 
		[self asciiValue between: $N asciiValue and: $Z asciiValue	].! !

$` asLowercase !

TDDBabyStepsGamePrimeFactors start!

!classDefinition: #TDDBabyStepsPrimeFactorsTest category: 'TDDBabyStepsGamePrimeFactors' stamp: 'TB 4/27/2023 19:18:06'!
TestCase subclass: #TDDBabyStepsPrimeFactorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGamePrimeFactors'!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:18:18'!
test01OneHasNoPrimeFactors
	
	self assert: Bag new equals: 1 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:18:30'!
ERROR!
!Integer methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:18:46'!
factorize
	self shouldBeImplemented.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:18:49'!
ERROR!
!SmallInteger methodsFor: 'error handling' stamp: 'TB 4/27/2023 19:18:55' overrides: 16902107!
error: aRenameMe1 
	self shouldBeImplemented.! !

!methodRemoval: SmallInteger #error: stamp: 'TB 4/27/2023 19:19:34'!
error: aRenameMe1 
	self shouldBeImplemented.!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:19:42'!
ERROR!

!methodRemoval: Integer #factorize stamp: 'TB 4/27/2023 19:19:55'!
factorize
	self shouldBeImplemented.!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:20:08'!
factorize
	
	^1! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:20:11' prior: 50608191!
factorize
	
	^Bag new! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:20:15'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:20:15'!
test02FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 2) equals: 2 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:20:15'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:20:15'!
test02FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 2) equals: 2 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:20:15'!
test02FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 2) equals: 2 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:20:15'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:21:04' prior: 50608195!
factorize
	
	self = 2 ifTrue: [^Bag with: self].
	^Bag new! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:21:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:21:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:21:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:21:06'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:21:06'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:21:06'!
test03FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 3) equals: 3 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:21:06'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:21:06'!
test03FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 3) equals: 3 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:21:06'!
test03FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 3) equals: 3 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:21:06'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:22:42' prior: 50608229!
factorize
	
	self isPrime ifTrue: [^Bag with: self].
	^Bag new! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:22:44'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:22:44'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:22:44'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:22:44'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:22:45'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:22:45'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:22:45'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:22:45'!
test04CorrectlyFactorizesACompositeNumberWithTwoFactors2
	
	self assert: (Bag with: 2 with: 2) equals: 4 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:22:45'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:22:45'!
test04CorrectlyFactorizesACompositeNumberWithTwoFactors2
	
	self assert: (Bag with: 2 with: 2) equals: 4 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:22:45'!
test04CorrectlyFactorizesACompositeNumberWithTwoFactors2
	
	self assert: (Bag with: 2 with: 2) equals: 4 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:22:45'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:23:50' prior: 50608280!
factorize
	
	self isPrime ifTrue: [^Bag with: self].
	self = 4 ifTrue: [^Bag with: 2 with: 2].
	^Bag new! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:23:51'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:23:51'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:23:51'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:23:51'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:23:51'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:23:53'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:23:53'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:23:53'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:23:53'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:23:53'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:23:53'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:23:53'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:23:53'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:23:53'!
FAILURE!

----SNAPSHOT----(27 April 2023 19:25:44) CuisUniversity-5706.image priorSource: 8713034!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50608342!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

4 / 2 !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50608420!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23'!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50608436!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:32:23'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50608443!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50608452!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:34:58'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:34:58'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:34:58'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:34:58'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:34:58'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:34:58'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50608467!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50608509!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:35:22'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:35:22'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:35:22'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:35:22'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:35:22'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:35:22'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50608475!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:36:08'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:36:08'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:36:08'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:36:08'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:36:08'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:36:08'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:36:12'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:36:33'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50608547!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50608590!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !

smallestDivisor !

self!

self!

smallestDivisor !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50608600!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50608611!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:41:34'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50608620!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:42:45'!
ERROR!

Bag new add: 5!

Bag new add: 5!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50608634!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:43:56'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:43:56'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:43:56'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:43:56'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:43:56'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:43:56'!
PASSED!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50608648!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:46:38'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:46:38'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:46:38'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:46:38'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:46:38'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:46:38'!
PASSED!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50608683!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:49:53'!
ERROR!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50608735!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:50:06'!
ERROR!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50608758!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:51:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:51:04'!
ERROR!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:51:04'!
ERROR!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:51:04'!
ERROR!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:51:04'!
ERROR!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:51:08'!
ERROR!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50608782!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:51:32'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:51:47'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50608826!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

----STARTUP---- (27 April 2023 19:53:39) as /home/clinux01/Descargas/linux64/CuisUniversity-5706.image!

!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50608342!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50608875!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23'!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50608891!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:53:41'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50608898!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50608907!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50608922!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50608941!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50608930!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50608955!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50608966!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50608976!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50608986!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50608995!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50609004!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50609013!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:53:41'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50609023!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50609050!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50609069!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50609088!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50609107!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:15' prior: 50609127!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(self / 2) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:54:17'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:54:17'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:54:17'!
PASSED!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:48' prior: 50609144!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[self / 2 isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:54:52'!
ERROR!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:55:01' prior: 50609172!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(self / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

----STARTUP---- (27 April 2023 19:55:22) as /home/clinux01/Descargas/linux64/CuisUniversity-5706.image!

!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50608342!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50609210!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23'!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50609226!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:55:24'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50609233!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50609242!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50609257!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50609276!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50609265!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50609290!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50609301!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50609311!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50609321!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50609330!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50609339!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50609348!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:55:24'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50609358!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50609385!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50609404!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50609423!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50609442!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50609462!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50609479!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50609284!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50609495!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:55:24'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50609502!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50609511!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50609526!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50609545!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50609534!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50609559!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50609570!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50609580!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50609590!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50609599!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50609608!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50609617!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:55:24'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50609627!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50609654!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50609673!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50609692!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50609711!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:15' prior: 50609731!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(self / 2) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:48' prior: 50609748!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[self / 2 isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:55:01' prior: 50609765!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(self / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

----STARTUP---- (27 April 2023 19:56:01) as /home/clinux01/Descargas/linux64/CuisUniversity-5706.image!

!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50608342!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50609800!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23'!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50609816!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:02'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50609823!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50609832!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50609847!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50609866!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50609855!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50609880!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50609891!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50609901!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50609911!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50609920!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50609929!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50609938!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:02'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50609948!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50609975!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50609994!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50610013!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50610032!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50610052!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50610069!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50609874!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50610085!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:02'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50610092!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50610101!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50610116!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50610135!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50610124!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50610149!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50610160!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50610170!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50610180!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50610189!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50610198!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50610207!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:02'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50610217!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50610244!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50610263!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50610282!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50610301!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:15' prior: 50610321!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(self / 2) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:48' prior: 50610338!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[self / 2 isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:55:01' prior: 50610355!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(self / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50610371!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50610387!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50610143!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50610403!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:02'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50610410!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50610419!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50610434!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50610453!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50610442!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50610467!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50610478!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50610488!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50610498!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50610507!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50610516!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50610525!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:02'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50610535!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50610562!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50610581!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50610600!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50610619!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50610639!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50610656!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50610461!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50610672!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:02'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50610679!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50610688!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50610703!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50610722!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50610711!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50610736!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50610747!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50610757!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50610767!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50610776!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50610785!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50610794!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:02'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50610804!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50610831!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50610850!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50610869!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50610888!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:15' prior: 50610908!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(self / 2) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:48' prior: 50610925!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[self / 2 isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:55:01' prior: 50610942!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(self / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:56:21' prior: 50610958!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(smallestDivisor / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:56:24' prior: 50610974!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(smallestDivisor / 2) isInteger] whileFalse: [
		smallestDivisor := smallestDivisor / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

----STARTUP---- (27 April 2023 19:56:39) as /home/clinux01/Descargas/linux64/CuisUniversity-5706.image!

!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50608342!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50611010!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23'!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50611026!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:40'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50611033!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50611042!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50611057!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50611076!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50611065!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50611090!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50611101!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50611111!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50611121!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50611130!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50611139!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50611148!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:40'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50611158!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50611185!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50611204!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50611223!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50611242!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50611262!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50611279!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50611084!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50611295!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:40'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50611302!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50611311!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50611326!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50611345!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50611334!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50611359!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50611370!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50611380!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50611390!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50611399!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50611408!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50611417!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:40'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50611427!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50611454!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50611473!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50611492!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50611511!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:15' prior: 50611531!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(self / 2) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:48' prior: 50611548!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[self / 2 isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:55:01' prior: 50611565!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(self / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50611581!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50611597!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50611353!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50611613!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:40'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50611620!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50611629!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50611644!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50611663!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50611652!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50611677!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50611688!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50611698!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50611708!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50611717!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50611726!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50611735!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:40'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50611745!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50611772!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50611791!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50611810!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50611829!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50611849!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50611866!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50611671!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50611882!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:40'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50611889!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50611898!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50611913!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50611932!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50611921!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50611946!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50611957!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50611967!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50611977!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50611986!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50611995!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50612004!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:40'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50612014!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50612041!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50612060!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50612079!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50612098!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:15' prior: 50612118!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(self / 2) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:48' prior: 50612135!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[self / 2 isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:55:01' prior: 50612152!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(self / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50612168!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50612184!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50611940!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50612200!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:40'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50612207!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50612216!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50612231!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50612250!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50612239!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50612264!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50612275!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50612285!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50612295!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50612304!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50612313!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50612322!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:40'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50612332!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50612359!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50612378!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50612397!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50612416!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50612436!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50612453!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50612258!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50612469!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:40'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50612476!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50612485!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50612500!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50612519!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50612508!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50612533!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50612544!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50612554!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50612564!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50612573!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50612582!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50612591!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:40'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50612601!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50612628!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50612647!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50612666!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50612685!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:15' prior: 50612705!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(self / 2) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:48' prior: 50612722!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[self / 2 isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:55:01' prior: 50612739!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(self / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50612755!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50612771!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50612527!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50612787!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:41'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50612794!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50612803!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50612818!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50612837!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50612826!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50612851!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50612862!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50612872!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50612882!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50612891!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50612900!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50612909!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:41'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50612919!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50612946!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50612965!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50612984!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50613003!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:27:11' prior: 50613023!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
	
	2 to: self sqrt floor do: [
			
		].
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:31:14'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:32:09' prior: 50613040!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self hasDivisors ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !
!SmallInteger methodsFor: 'testing' stamp: 'TB 4/27/2023 19:32:23' prior: 50612845!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 19:32:23' prior: 50613056!
factorize
	
	self = 1 ifTrue: [^Bag new].	
	self smallestDivisor ifFalse: [^Bag with: self].
		
	self = 4 ifTrue: [^Bag with: 2 with: 2].! !

!methodRemoval: SmallInteger #hasDivisors stamp: 'TB 4/27/2023 19:56:41'!
hasDivisors

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | hasDivisors := hasDivisors & (self / divisor) isInteger ].
	^hasDivisors!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:33:13' prior: 50613063!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self sqrt floor do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:34:52' prior: 50613072!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	smallestDivisor = self ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:13' prior: 50613087!
smallestDivisor

	| hasDivisors |
	hasDivisors := false.
	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:35:18' prior: 50613106!
smallestDivisor

	2 to: self do: [ :divisor | (self / divisor) isInteger ifTrue: [^divisor] ].
	^self! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:03' prior: 50613095!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].	
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:36:55' prior: 50613120!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.
	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:37:01' prior: 50613131!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(Bag with: smallestDivisor) addAll: (self / smallestDivisor) factorize! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:31' prior: 50613141!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor.! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:41:32' prior: 50613151!
factorize
	
	| smallestDivisor |
	smallestDivisor := self smallestDivisor	.	
	self / smallestDivisor = 1 ifTrue: [^Bag with: self].
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:42:29' prior: 50613160!
factorize
	
	| smallestDivisor |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	^(self / smallestDivisor) factorize add: smallestDivisor! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:43:51' prior: 50613169!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor	.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:44:35' prior: 50613178!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:46:38'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:56:41'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:49:51' prior: 50613188!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:50:04' prior: 50613215!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	smallestDivisor = 1 whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:02' prior: 50613234!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:51:29' prior: 50613253!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		2 to: self do: [:aPossibleDivisor | (aPossibleDivisor / self) isInteger ifTrue: [
				smallestDivisor := aPossibleDivisor / self.		
				primeFactors add: smallestDivisor.
			]
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:52:17' prior: 50613272!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(2 / self) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:15' prior: 50613292!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[smallestDivisor = 1] whileFalse: [
		(self / 2) isInteger ifTrue: [
			smallestDivisor := self / 2.		
			primeFactors add: 2.
		]
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:54:48' prior: 50613309!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[self / 2 isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:55:01' prior: 50613326!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(self / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:56:21' prior: 50613342!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(smallestDivisor / 2) isInteger] whileFalse: [
		smallestDivisor := self / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:56:24' prior: 50613358!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(smallestDivisor / 2) isInteger] whileFalse: [
		smallestDivisor := smallestDivisor / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:56:58' prior: 50613374!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(smallestDivisor / 2) isInteger] whileTrue: [
		smallestDivisor := smallestDivisor / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:56:59'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:56:59'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:56:59'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:56:59'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:56:59'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:56:59'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:56:59'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:58:04' prior: 50613390!
factorize
	
	| smallestDivisor primeFactors |
	"self = 1 ifTrue: [^Bag new]."
	self isPrime ifTrue: [^Bag with: self].
	smallestDivisor := self.
	primeFactors := Bag new.
	
	[(smallestDivisor / 2) isInteger] whileTrue: [
		smallestDivisor := smallestDivisor / 2.		
		primeFactors add: 2.
	].

	^primeFactors 
	
	"smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors"! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:58:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:58:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:58:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:58:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:58:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:58:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:58:08'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:58:08'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:58:08'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:58:08'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:58:08'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:58:08'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:58:08'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:58:08'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:58:08'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:58:08'!
FAILURE!
!SmallInteger methodsFor: 'arithmetic' stamp: 'TB 4/27/2023 19:58:29' prior: 50613434!
factorize
	
	| smallestDivisor primeFactors |
	self = 1 ifTrue: [^Bag new].
	
	smallestDivisor := self smallestDivisor.	
	primeFactors := (self / smallestDivisor) factorize.
	primeFactors add: smallestDivisor.
	^primeFactors! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:58:30'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:58:30'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:58:30'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:58:30'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:58:30'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:58:30'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:58:30'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TB 4/27/2023 19:58:33'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:58:33'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TB 4/27/2023 19:58:33'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TB 4/27/2023 19:58:33'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TB 4/27/2023 19:58:33'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TB 4/27/2023 19:58:33'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 19:58:33'!
testExtraToCheckGeneralizationOnKata
	
	self assert: (Bag with: 2 with: 2 with: 3 with: 3 with: 5 with: 13) equals: (2*2*3*3*5*13) factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #testExtraToCheckGeneralizationOnKata stamp: 'TB 4/27/2023 19:58:33'!
PASSED!

----SNAPSHOT----(27 April 2023 19:58:47) CuisUniversity-5706.image priorSource: 8856507!

TDDBabyStepsGameAnagrams start!

!classDefinition: #TDDBabyStepsAnagramsTest category: 'TDDBabyStepsGameAnagrams' stamp: 'TB 4/27/2023 20:24:35'!
TestCase subclass: #TDDBabyStepsAnagramsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameAnagrams'!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 20:24:40'!
test01EmptyStringAnagramIsJustACollectionWithTheEmptyString

	self assert: (Set with: '') equals: '' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:24:50'!
ERROR!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:25:08'!
anagrams
	self shouldBeImplemented.! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:25:18' prior: 50613630!
anagrams
	^Set with: ''! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:25:23'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:25:23'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:26:39'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 20:26:39'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:26:39'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:26:39'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 20:26:39'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:26:39'!
FAILURE!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:27:17' prior: 50613634!
anagrams
	^Set with: self! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:27:19'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:27:19'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:27:19'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:27:21'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:27:21'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 20:27:21'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 20:27:21'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 20:27:21'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 20:27:21'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 20:27:21'!
FAILURE!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:27:39' prior: 50613683!
anagrams
	^Set with: self with: self reversed ! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:27:40'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:27:40'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 20:27:40'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 20:27:40'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:27:40'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:27:40'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 20:27:40'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:27:40'!
FAILURE!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:33:14' prior: 50613742!
anagrams
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	^(Set with: self with: self reversed) addAll: (self copyFrom: 1 to: self size) anagrams.! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:33:27' prior: 50613807!
anagrams
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	^(Set with: self with: self reversed) addAll: (self copyFrom: 2 to: self size) anagrams.! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:33:28'!
FAILURE!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:34:07' prior: 50613815!
anagrams
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	anagrams addAll: (self copyFrom: 2 to: self size) anagrams.
	^anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:34:10'!
FAILURE!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:36:12' prior: 50613828!
anagrams
	| anagrams substringAnagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	substringAnagrams := (self copyFrom: 2 to: self size) anagrams.
	
	self do: [ :aLetter |
		substringAnagrams do: [ :anAnagram |
			anagrams addAll: aLetter, anAnagram
			].		
	]
	^anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:36:15' prior: 50613842!
anagrams
	| anagrams substringAnagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	substringAnagrams := (self copyFrom: 2 to: self size) anagrams.
	
	self do: [ :aLetter |
		substringAnagrams do: [ :anAnagram |
			anagrams addAll: aLetter, anAnagram
		].		
	]
	^anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:36:17'!
ERROR!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:36:26' prior: 50613856!
anagrams
	| anagrams substringAnagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	substringAnagrams := (self copyFrom: 2 to: self size) anagrams.
	
	self do: [ :aLetter |
		substringAnagrams do: [ :anAnagram |
			anagrams addAll: aLetter, anAnagram
		].		
	].
	^anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:36:27'!
ERROR!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:36:33' prior: 50613874!
anagrams
	| anagrams substringAnagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	substringAnagrams := (self copyFrom: 2 to: self size) anagrams.
	
	self do: [ :aLetter |
		substringAnagrams do: [ :anAnagram |
			anagrams addAll: aLetter asString, anAnagram
		].		
	].
	^anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:36:34'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:37:10'!
FAILURE!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:38:35' prior: 50613892!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set new.! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:40:20' prior: 50613915!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(self copyFrom: 2 to: self size) anagrams do: [ :aSubanagram |
		anagrams add: (self at: 1) asString, aSubanagram
	]! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:40:37' prior: 50613922!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(self copyFrom: 2 to: 3) anagrams do: [ :aSubanagram |
		anagrams add: (self at: 1) asString, aSubanagram
	]! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:41:48' prior: 50613933!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(self copyFrom: 1 to: 2) anagrams do: [ :aSubanagram |
		anagrams add: (self	 at: 3) asString, aSubanagram
	].

	(self copyFrom: 2 to: 3) anagrams do: [ :aSubanagram |
		anagrams add: (self at: 1) asString, aSubanagram
	].

	^anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:41:50'!
FAILURE!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:42:47' prior: 50613944!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(self copyFrom: 1 to: 2) anagrams do: [ :aSubanagram |
		anagrams add: (self	 at: 3) asString, aSubanagram
	].

	(String with: (self at: 1) with: (self at: 3)) anagrams do: [ :aSubanagram | 
		anagrams add: (self at: 2) asString, aSubanagram 
	].

	(self copyFrom: 2 to: 3) anagrams do: [ :aSubanagram |
		anagrams add: (self at: 1) asString, aSubanagram
	].

	^anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:42:49'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:42:49'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:42:49'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 20:42:49'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:42:49'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:42:53'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:42:53'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 20:42:53'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:42:53'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 20:42:53'!
test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abcd'; add: 'abdc'; add: 'acbd'; add: 'acdb'; add: 'adbc'; add: 'adcb'; add: 'bacd'; add: 'badc'; add: 'bcad'; add: 'bcda'; add: 'bdac'; add: 'bdca'; add: 'cabd'; add: 'cadb'; add: 'cbad'; add: 'cbda'; add: 'cdab'; add: 'cdba'; add: 'dabc'; add: 'dacb'; add: 'dbac'; add: 'dbca'; add: 'dcab'; add: 'dcba'.

	self assert: anagrams equals: 'abcd' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 20:42:53'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 20:42:53'!
test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abcd'; add: 'abdc'; add: 'acbd'; add: 'acdb'; add: 'adbc'; add: 'adcb'; add: 'bacd'; add: 'badc'; add: 'bcad'; add: 'bcda'; add: 'bdac'; add: 'bdca'; add: 'cabd'; add: 'cadb'; add: 'cbad'; add: 'cbda'; add: 'cdab'; add: 'cdba'; add: 'dabc'; add: 'dacb'; add: 'dbac'; add: 'dbca'; add: 'dcab'; add: 'dcba'.

	self assert: anagrams equals: 'abcd' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 20:42:53'!
test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abcd'; add: 'abdc'; add: 'acbd'; add: 'acdb'; add: 'adbc'; add: 'adcb'; add: 'bacd'; add: 'badc'; add: 'bcad'; add: 'bcda'; add: 'bdac'; add: 'bdca'; add: 'cabd'; add: 'cadb'; add: 'cbad'; add: 'cbda'; add: 'cdab'; add: 'cdba'; add: 'dabc'; add: 'dacb'; add: 'dbac'; add: 'dbca'; add: 'dcab'; add: 'dcba'.

	self assert: anagrams equals: 'abcd' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 20:42:53'!
FAILURE!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:47:05'!
subanagramsSkipping: anIndex
	| anagrams substring |
	substring := self copyFrom: 1 to: anIndex - 1.
	substring addAll: (self copyFrom: anIndex + 1 to: self size).
		
	^substring anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:47:09' prior: 50614090!
subanagramsSkipping: anIndex
	| substring |
	substring := self copyFrom: 1 to: anIndex - 1.
	substring addAll: (self copyFrom: anIndex + 1 to: self size).
		
	^substring anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:50:40' prior: 50613963!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(1 to: self size) do: [ :anIndex |
		(self subanagramsSkipping: anIndex) do: [ :aSubanagram |
			anagrams add: (self	 at: anIndex) asString, aSubanagram
		].
		
	].
	
	^anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 20:50:42'!
ERROR!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:51:06' prior: 50614108!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(1 to: self size) do: [ :anIndex |
		(self subanagramsSkipping: anIndex) do: [ :aSubanagram |
			anagrams add: (self	 at: anIndex) asString, aSubanagram
		].		
	].
	
	^anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:51:59' prior: 50614099!
subanagramsSkipping: anIndex
	| substring |
	substring := self copyFrom: 1 to: anIndex - 1.
	substring, (self copyFrom: anIndex + 1 to: self size).
		
	^substring anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:52:30' prior: 50614139!
subanagramsSkipping: anIndex
	| substring |
	substring := self copyFrom: 1 to: anIndex - 1.
	substring := substring, (self copyFrom: anIndex + 1 to: self size).
		
	^substring anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 20:52:31'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 20:52:31'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 20:52:31'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 20:52:31'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 20:52:31'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 20:52:31'!
PASSED!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:54:06'!
skipping: anIndex
	^(self copyFrom: 1 to: anIndex - 1), (self copyFrom: anIndex + 1 to: self size)! !

!methodRemoval: String #subanagramsSkipping: stamp: 'TB 4/27/2023 20:54:25'!
subanagramsSkipping: anIndex
	| substring |
	substring := self copyFrom: 1 to: anIndex - 1.
	substring := substring, (self copyFrom: anIndex + 1 to: self size).
		
	^substring anagrams!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:54:32' prior: 50614126!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(1 to: self size) do: [ :anIndex |
		(self skipping: anIndex) anagrams do: [ :aSubanagram |
			anagrams add: (self	 at: anIndex) asString, aSubanagram
		].		
	].
	
	^anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 20:57:02' prior: 50614197!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(1 to: self size) do: [ :anIndex |
		(self skipping: anIndex) anagrams do: [ :aSubanagram |
			anagrams add: (self	 at: anIndex) asString, aSubanagram
		].
	].
	
	^anagrams! !
!String methodsFor: 'copying' stamp: 'TB 4/27/2023 20:59:53'!
copySkipping: anIndex
	^(self copyFrom: 1 to: anIndex - 1), (self copyFrom: anIndex + 1 to: self size)! !
!String methodsFor: 'as yet unclassified' stamp: 'TB 4/27/2023 20:59:53' prior: 50614210!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(1 to: self size) do: [ :anIndex |
		(self copySkipping: anIndex) anagrams do: [ :aSubanagram |
			anagrams add: (self	 at: anIndex) asString, aSubanagram
		].
	].
	
	^anagrams! !

!methodRemoval: String #skipping: stamp: 'TB 4/27/2023 20:59:53'!
skipping: anIndex
	^(self copyFrom: 1 to: anIndex - 1), (self copyFrom: anIndex + 1 to: self size)!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:01:45'!
combinationsOf: aStringToPrefix with: aCollectionOfStrings

	^aCollectionOfStrings collect: [ :aStringToCombine |
		aStringToPrefix, aStringToCombine
	]! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:02:43' prior: 50614229!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(1 to: self size) do: [ :anIndex |
		anagrams addAll: (self combinationsOf: (self at: anIndex) asString with: (self copySkipping: anIndex) anagrams)
	].
	
	^anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 21:02:45'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 21:02:45'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 21:02:45'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 21:02:45'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 21:02:45'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 21:02:45'!
PASSED!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:03:07' prior: 50614247!
combinationsOf: aCharacterToPrefix with: aCollectionOfStrings

	^aCollectionOfStrings collect: [ :aStringToCombine |
		aCharacterToPrefix, aStringToCombine
	]! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:03:10' prior: 50614296!
combinationsOf: aCharacterToPrefix with: aCollectionOfStrings

	^aCollectionOfStrings collect: [ :aStringToCombine |
		aCharacterToPrefix asString, aStringToCombine
	]! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:03:14' prior: 50614255!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(1 to: self size) do: [ :anIndex |
		anagrams addAll: (self combinationsOf: (self at: anIndex) with: (self copySkipping: anIndex) anagrams)
	].
	
	^anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:04:10' prior: 50614312!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(1 to: self size) do: [ :anIndex | | subanagrams |
		subanagrams := self combinationsOf: (self at: anIndex) with: (self copySkipping: anIndex) anagrams.
		anagrams addAll: subanagrams
	].
	
	^anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:04:56' prior: 50614324!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	(1 to: self size) do: [ :anIndex | | subanagrams combinationsWithCurrentCharacter |
		subanagrams := (self copySkipping: anIndex) anagrams.
		combinationsWithCurrentCharacter := self combinationsOf: (self at: anIndex) with: subanagrams.
		anagrams addAll: combinationsWithCurrentCharacter
	].
	
	^anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:05:57'!
doEnumerated: aTwoValueClosure
	(1 to: self size) do: [ :anIndex | 
		aTwoValueClosure value: anIndex value: (self at: anIndex)
	]! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:05:58' prior: 50614355!
doEnumerated: aTwoValueClosure
	
	(1 to: self size) do: [ :anIndex | 
		aTwoValueClosure value: anIndex value: (self at: anIndex)
	]! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:06:10' prior: 50614338!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	self doEnumerated: [ :anIndex :aCharacter | | subanagrams combinationsWithCurrentCharacter |
		subanagrams := (self copySkipping: anIndex) anagrams.
		combinationsWithCurrentCharacter := self combinationsOf: (self at: anIndex) with: subanagrams.
		anagrams addAll: combinationsWithCurrentCharacter
	].
	
	^anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:06:18' prior: 50614369!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	self doEnumerated: [ :anIndex :aCharacter | | subanagrams combinationsWithCurrentCharacter |
		subanagrams := (self copySkipping: anIndex) anagrams.
		combinationsWithCurrentCharacter := self combinationsOf: aCharacter with: subanagrams.
		anagrams addAll: combinationsWithCurrentCharacter
	].
	
	^anagrams! !

----SNAPSHOT----(27 April 2023 21:06:38) CuisUniversity-5706.image priorSource: 9022600!
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:07:03' prior: 50614386!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	self doEnumerated: [ :anIndex :aCharacter | | subanagrams |
		subanagrams := (self copySkipping: anIndex) anagrams.
		anagrams addAll: (self combinationsOf: aCharacter with: subanagrams)
	].
	
	^anagrams! !
!String methodsFor: 'accessing' stamp: 'TB 4/27/2023 21:07:15' prior: 50614406!
anagrams
	
	| anagrams |
	self size < 3 ifTrue: [^Set with: self with: self reversed].
	
	anagrams := Set with: self with: self reversed.
	
	self doEnumerated: [ :anIndexOf :aCharacter | | subanagrams |
		subanagrams := (self copySkipping: anIndexOf) anagrams.
		anagrams addAll: (self combinationsOf: aCharacter with: subanagrams)
	].
	
	^anagrams! !

----SNAPSHOT----(27 April 2023 21:07:28) CuisUniversity-5706.image priorSource: 9048066!

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 21:07:29'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 21:07:29'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 21:07:29'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 21:07:29'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 21:07:29'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 21:07:29'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TB 4/27/2023 21:07:33'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TB 4/27/2023 21:07:33'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TB 4/27/2023 21:07:33'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TB 4/27/2023 21:07:33'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'TB 4/27/2023 21:07:33'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TB 4/27/2023 21:07:33'!
testExtraToCheckGeneralizationOnKata

	self assert: 40320 equals:`'abcdefgh' anagrams` size.
	
	self assert: (`'abcdefgh' anagrams`) includes: 'cghdbeaf'.
	
	self assert: 10080 equals: `'abcdefab' anagrams` size
	! !

!testRun: #TDDBabyStepsAnagramsTest #testExtraToCheckGeneralizationOnKata stamp: 'TB 4/27/2023 21:07:34'!
PASSED!